#!/usr/bin/env bash
# Quick commands for managing remote GPU worker
#
# Usage:
#   scripts/worker/remote COMMAND [user@]host[:port]
#
# Examples:
#   scripts/worker/remote status user@192.168.1.20:2222
#   scripts/worker/remote sync 192.168.1.20:2222
#   REMOTE_HOST=192.168.1.20 REMOTE_PORT=2222 scripts/worker/remote logs

# Parse connection info from last argument if it looks like user@host or host:port
LAST_ARG="${!#}"
if [[ "$LAST_ARG" =~ @ ]] || [[ "$LAST_ARG" =~ : ]] && [[ "$LAST_ARG" != "${1:-}" ]]; then
  # Last arg is connection info, extract command from first arg
  COMMAND="${1:-help}"
  if [[ "$LAST_ARG" =~ ^([^@]+)@([^:]+):([0-9]+)$ ]]; then
    REMOTE_USER="${BASH_REMATCH[1]}"
    REMOTE_HOST="${BASH_REMATCH[2]}"
    REMOTE_PORT="${BASH_REMATCH[3]}"
  elif [[ "$LAST_ARG" =~ ^([^@]+)@([^:]+)$ ]]; then
    REMOTE_USER="${BASH_REMATCH[1]}"
    REMOTE_HOST="${BASH_REMATCH[2]}"
    REMOTE_PORT="${REMOTE_PORT:-22}"
  elif [[ "$LAST_ARG" =~ ^([^:]+):([0-9]+)$ ]]; then
    REMOTE_HOST="${BASH_REMATCH[1]}"
    REMOTE_PORT="${BASH_REMATCH[2]}"
    REMOTE_USER="${REMOTE_USER:-${USER}}"
  else
    REMOTE_HOST="$LAST_ARG"
    REMOTE_USER="${REMOTE_USER:-${USER}}"
    REMOTE_PORT="${REMOTE_PORT:-22}"
  fi
else
  COMMAND="${1:-help}"
  REMOTE_USER="${REMOTE_USER:-${USER}}"
  REMOTE_HOST="${REMOTE_HOST:-}"
  REMOTE_PORT="${REMOTE_PORT:-22}"
fi

REMOTE_PATH="${REMOTE_PATH:-~/ClippyFront}"

# Validate we have a host
if [[ -z "$REMOTE_HOST" ]] && [[ "$COMMAND" != "help" ]]; then
  echo "Error: No remote host specified" >&2
  echo "" >&2
  echo "Usage: $0 COMMAND [user@]host[:port]" >&2
  echo "" >&2
  echo "Examples:" >&2
  echo "  $0 status winter@192.168.1.20:2222" >&2
  echo "  $0 sync 192.168.1.20:2222" >&2
  echo "  REMOTE_HOST=192.168.1.20 REMOTE_PORT=2222 $0 logs" >&2
  echo "" >&2
  echo "Or set environment variables:" >&2
  echo "  export REMOTE_HOST=192.168.1.20" >&2
  echo "  export REMOTE_USER=user" >&2
  echo "  export REMOTE_PORT=2222" >&2
  exit 1
fi

case "${COMMAND}" in
  sync)
    echo "Syncing code to ${REMOTE_HOST}..."
    "$(dirname "${BASH_SOURCE[0]}")/sync-to-remote.sh" "$REMOTE_USER@$REMOTE_HOST:$REMOTE_PORT" "$REMOTE_PATH"
    ;;
  start)
    echo "Starting worker on ${REMOTE_HOST}..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
cd ~/ClippyFront

# Create dev worker .env if it doesn't exist
if [[ ! -f .env.worker ]]; then
  cat > .env.worker << 'EOF'
# Development worker configuration
TABLE_PREFIX=dev_
REDIS_URL=redis://10.8.0.1:6379/0
REDIS_DB=0
CELERY_BROKER_URL=redis://10.8.0.1:6379/0
CELERY_RESULT_BACKEND=redis://10.8.0.1:6379/0
DATABASE_URL=postgresql://postgres:8675309@10.8.0.1/clippy_front
FLASK_APP_URL=http://10.8.0.1:5000
MEDIA_BASE_URL=http://10.8.0.1:5000
WORKER_API_KEY=y5qknbhck7IEzEDErjezi6-0hmiyi9f-3_0jgonBc3g
USE_GPU_QUEUE=1
# Instance path for structured logging (all logs go to instance/logs/)
CLIPPY_INSTANCE_PATH=/home/winter/ClippyFront/instance
EOF
fi

# Backup original .env and use worker config
if [[ -f .env ]] && [[ ! -f .env.dev-backup ]]; then
  mv .env .env.dev-backup
fi
cp .env.worker .env

# Ensure logs directory exists
mkdir -p instance/logs

# Remote GPU workers should ONLY process the gpu queue, not celery queue
# Pass 0 as 4th argument for dev (Redis DB 0), or 1 for production (Redis DB 1)
# Logs will go to instance/logs/worker.json via structlog
nohup ./scripts/worker/start-celery-versioned.sh tundra-gpu "gpu" 2 0 > /dev/null 2>&1 &
sleep 2
echo "Worker started. Logs: ~/ClippyFront/instance/logs/worker.json"
ps aux | grep celery | grep -v grep | head -2
ENDSSH
    ;;
  stop)
    echo "Stopping worker on ${REMOTE_HOST}..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
pkill -f 'celery.*worker' && echo 'Worker stopped' || echo 'Worker not running'
exit 0
ENDSSH
    ;;
  restart)
    echo "Restarting worker on ${REMOTE_HOST}..."
    # Kill existing workers
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "pkill -9 -f 'celery.*worker' 2>/dev/null || true"

    # Wait for processes to terminate
    sleep 2

    # Verify they're dead (before starting new ones)
    if ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "pgrep -f 'celery.*worker' >/dev/null 2>&1"; then
      echo "WARNING: Some workers still running after kill signal, waiting..."
      sleep 3
      # Force kill any stragglers
      ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "pkill -9 -f 'celery.*worker' 2>/dev/null || true"
      sleep 1
    fi

    # Start new worker using the script (which handles backgrounding properly)
    echo "Starting new worker..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
cd ~/ClippyFront

# Create dev worker .env if it doesn't exist
if [[ ! -f .env.worker ]]; then
  cat > .env.worker << 'EOF'
# Development worker configuration
TABLE_PREFIX=dev_
REDIS_URL=redis://10.8.0.1:6379/0
REDIS_DB=0
CELERY_BROKER_URL=redis://10.8.0.1:6379/0
CELERY_RESULT_BACKEND=redis://10.8.0.1:6379/0
DATABASE_URL=postgresql://postgres:8675309@10.8.0.1/clippy_front
FLASK_APP_URL=http://10.8.0.1:5000
MEDIA_BASE_URL=http://10.8.0.1:5000
WORKER_API_KEY=y5qknbhck7IEzEDErjezi6-0hmiyi9f-3_0jgonBc3g
USE_GPU_QUEUE=1
# Instance path for structured logging (all logs go to instance/logs/)
CLIPPY_INSTANCE_PATH=/home/winter/ClippyFront/instance
EOF
fi

# Use worker config
cp .env.worker .env

# Ensure logs directory exists
mkdir -p instance/logs

# Remote GPU workers should ONLY process the gpu queue, not celery queue
# Pass 0 as 4th argument for dev (Redis DB 0), or 1 for production (Redis DB 1)
# Logs will go to instance/logs/worker.json via structlog
bash ./scripts/worker/start-celery-versioned.sh tundra-gpu 'gpu' 2 0 > /dev/null 2>&1 &
ENDSSH

    sleep 3

    # Show status
    echo "Worker status:"
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "ps aux | grep 'celery.*worker' | grep -v grep || echo 'No workers running'"
    echo "Logs: ~/ClippyFront/instance/logs/worker.json"
    ;;
  logs)
    echo "Tailing worker logs on ${REMOTE_HOST}..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
# Check for structured logs first (JSON format), fall back to old locations
if [[ -f ~/ClippyFront/instance/logs/worker.json ]]; then
  echo "=== Structured logs (instance/logs/worker.json) ==="
  tail -f ~/ClippyFront/instance/logs/worker.json
elif [[ -f /mnt/clippyfront/instance/logs/worker.json ]]; then
  echo "=== Structured logs (/mnt/clippyfront/instance/logs/worker.json) ==="
  tail -f /mnt/clippyfront/instance/logs/worker.json
elif [[ -f ~/ClippyFront/worker.log ]]; then
  echo "=== Legacy logs (worker.log) ==="
  tail -f ~/ClippyFront/worker.log
else
  echo 'No worker logs found. Expected locations:'
  echo '  - ~/ClippyFront/instance/logs/worker.json (structlog)'
  echo '  - /mnt/clippyfront/instance/logs/worker.json (container)'
  echo '  - ~/ClippyFront/worker.log (legacy)'
fi
ENDSSH
    ;;
  status)
    echo "Checking worker status on ${REMOTE_HOST}..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
ps aux | grep celery | grep -v grep && echo '' && echo 'Worker is running' || echo 'Worker is not running'
ENDSSH
    ;;
  shell)
    echo "Opening SSH session to ${REMOTE_HOST}..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST}
    ;;
  inspect)
    echo "Inspecting Celery worker queues..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
cd ~/ClippyFront
source venv/bin/activate
celery -A app.tasks.celery_app inspect active_queues
ENDSSH
    ;;
  gpu)
    echo "Checking GPU status on ${REMOTE_HOST}..."
    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} bash << 'ENDSSH'
nvidia-smi || echo 'nvidia-smi not found'
ENDSSH
    ;;
  help|*)
    echo "Usage: $0 COMMAND [user@]host[:port]"
    echo
    echo "Commands:"
    echo "  sync     - Rsync code to remote worker"
    echo "  start    - Start Celery worker"
    echo "  stop     - Stop Celery worker"
    echo "  restart  - Restart Celery worker"
    echo "  logs     - Tail worker logs"
    echo "  status   - Check if worker is running"
    echo "  shell    - Open SSH session"
    echo "  inspect  - Show active queues"
    echo "  gpu      - Check GPU status"
    echo
    echo "Connection:"
    echo "  Specify connection as: [user@]host[:port]"
    echo
    echo "Examples:"
    echo "  $0 status user@192.168.1.20:2222"
    echo "  $0 sync 192.168.1.20:2222"
    echo
    echo "Environment Variables:"
    echo "  REMOTE_HOST=hostname    (required if not in command)"
    echo "  REMOTE_USER=username    (default: \$USER)"
    echo "  REMOTE_PORT=port        (default: 22)"
    echo "  REMOTE_PATH=path        (default: ~/ClippyFront)"
    [[ "$COMMAND" == "help" ]] && exit 0 || exit 1
    ;;
esac
